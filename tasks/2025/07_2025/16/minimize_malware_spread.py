from collections import Counter


def min_malware_spread(graph, initial):
    n = len(graph)
    colors = {}
    color_id = 0

    # DFS для раскраски компонент
    def dfs(node, color):
        colors[node] = color
        for neighbor, connected in enumerate(graph[node]):
            if connected and neighbor not in colors:
                dfs(neighbor, color)

    # 1. Раскрашиваем компоненты
    for node in range(n):
        if node not in colors:
            dfs(node, color_id)
            color_id += 1

    # 2. Подсчитываем размер каждой компоненты
    size = Counter(colors.values())

    # 3. Подсчитываем количество заражённых в каждой компоненте
    infected_count = Counter()
    for node in initial:
        infected_count[colors[node]] += 1

    # 4. Выбираем узел, удаление которого минимизирует заражение
    result = float("inf")
    max_saved = -1

    for node in sorted(initial):  # сортировка — чтобы выбрать минимальный индекс при равенстве
        color = colors[node]
        if infected_count[color] == 1:
            saved = size[color]
            if saved > max_saved:
                max_saved = saved
                result = node

    # Если нет "уникально заражённых" компонент — вернуть минимальный индекс
    return result if result != float("inf") else min(initial)


if __name__ == "__main__":
    graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    initial = [0, 1]

    assert min_malware_spread(graph, initial) == 0
